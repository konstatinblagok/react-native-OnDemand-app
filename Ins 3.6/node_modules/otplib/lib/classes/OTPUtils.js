'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

/**
 *
 * OTP Utilities
 *
 * @class OTPUtils
 * @since 3.0.0
 * @author Gerald Yeo
 * @license MIT
 *
 */

var OTPUtils = (function () {
    function OTPUtils() {
        _classCallCheck(this, OTPUtils);
    }

    _createClass(OTPUtils, null, [{
        key: 'isSameToken',

        /**
         * Simple comparison of 2 tokens
         *
         * @method isSameToken
         * @static
         *
         * @param {string} token1 - value
         * @param {string} token2 - value to compare
         * @return {boolean}
         */
        value: function isSameToken(token1, token2) {
            return parseInt(token1) === parseInt(token2);
        }

        /**
         * Converts a string to Hex value
         *
         * @method stringToHex
         * @static
         *
         * @param {string} value - the string value to convert
         * @return {string}
         */
    }, {
        key: 'stringToHex',
        value: function stringToHex(value) {
            var hex = '';
            var tmp = '';

            for (var i = 0; i < value.length; i++) {

                // Convert to Hex and Ensure it's in 2 digit sets
                tmp = ('0000' + value.charCodeAt(i).toString(16)).slice(-2);

                // Append
                hex += '' + tmp;
            }

            return hex;
        }

        /**
         * Converts Hex into an Integer
         *
         * @method hexToInt
         * @static
         *
         * @param {string} value - the hex value to convert
         * @return {string}
         */
    }, {
        key: 'hexToInt',
        value: function hexToInt(hex) {
            return parseInt(hex, 16);
        }

        /**
         * Parses a number into an Integer and converts to it to Hex value
         *
         * @method intToHex
         * @static
         *
         * @param {number|string} num - the number to convert to hex
         * @return {string}
         */
    }, {
        key: 'intToHex',
        value: function intToHex(num) {
            return parseInt(num).toString(16);
        }

        /**
         * Do a left padding of the value based on the total
         *
         * @method pad
         * @static
         *
         * @param {integer} num - the number to convert to hex
         * @return {string}
         */
    }, {
        key: 'pad',
        value: function pad(value) {
            var total = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

            // Convert to string
            value = value + '';

            // Padding
            while (value.length < total) {
                value = '0' + value;
            }

            return value;
        }

        /**
         * Naive secret key generation tool
         *
         * @method generateSecret
         * @static
         *
         * @param {integer} len - the key length
         * @param {string} format - any format supported by node's `crypto`
         * @return {string}
         */
    }, {
        key: 'generateSecret',
        value: function generateSecret() {
            var len = arguments.length <= 0 || arguments[0] === undefined ? 16 : arguments[0];
            var format = arguments.length <= 1 || arguments[1] === undefined ? 'base64' : arguments[1];

            if (len < 1) {
                return '';
            }

            var random = _crypto2['default'].randomBytes(len).toString(format) // convert format
            .slice(0, len); // return required number of characters

            return random;
        }

        /**
         * Removes all spaces
         *
         * @method removeSpaces
         * @static
         *
         * @param {string} value - string to parse
         * @return {string}
         */
    }, {
        key: 'removeSpaces',
        value: function removeSpaces() {
            var value = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

            return value.replace(/\s+/g, '');
        }

        /**
         * Divides number/string into defined quantity per set
         *
         * @method setsOf
         * @static
         *
         * @param {string} value - string value to split
         * @param {integer} num - quantity per set
         * @return {string}
         */
    }, {
        key: 'setsOf',
        value: function setsOf(value) {
            var num = arguments.length <= 1 || arguments[1] === undefined ? 4 : arguments[1];

            var regex = new RegExp('.{1,' + num + '}', 'g');
            value = value + '';

            return value ? value.match(regex).join(' ') : '';
        }
    }]);

    return OTPUtils;
})();

exports['default'] = OTPUtils;
module.exports = exports['default'];