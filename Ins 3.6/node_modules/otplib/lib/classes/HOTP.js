'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _OTPUtils = require('./OTPUtils');

var _OTPUtils2 = _interopRequireDefault(_OTPUtils);

/**
 *
 * HMAC-based One-time Password Algorithm
 *
 * References
 * --------------------------
 * - http://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm
 * - http://tools.ietf.org/html/rfc4226
 *
 * Algorithm
 * --------------------------
 * ```
 *  K be a secret secret
 *  C be a counter
 *  HMAC(K,C) = SHA1(K & 0x5c5c... | SHA1(K & 0x3636... | C))
 *  be an HMAC calculated with the SHA-1 cryptographic hash algorithm
 *  Truncate be a function that selects 4 bytes from the result of the
 *  HMAC in a defined manner
 *  HOTP(K,C) = Truncate(HMAC(K,C)) & 0x7FFFFFFF
 *  HOTP-Value = HOTP(K,C) mod 10d, where d is the desired number of digits
 * ```
 *
 * @class HOTP
 * @since 3.0.0
 * @author Gerald Yeo
 * @license MIT
 *
 */

var HOTP = (function () {

  /**
   * Creates the instance
   */

  function HOTP() {
    _classCallCheck(this, HOTP);

    /**
     * @type {class}
     */
    this.utils = _OTPUtils2['default'];

    /**
     * @type {number}
     */
    this.digits = 6;
  }

  /**
   * Option Setter
   *
   * @method options
   *
   * @param {Object} opt - custom options
   */

  _createClass(HOTP, [{
    key: 'options',
    value: function options() {
      var opt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      this.digits = opt.digits || this.digits;
    }

    /**
     * Generates the OTP code
     *
     * @method generate
     *
     * @param {string} secret - your secret that is used to generate the token
     * @param {number} counter - the OTP counter (usually it's an incremental count)
     * @return {number} OTP Code
     */
  }, {
    key: 'generate',
    value: function generate(secret, counter) {

      // Convert secret to hex
      secret = _OTPUtils2['default'].stringToHex(secret);

      // Ensure counter is a buffer or string (for HMAC creation)
      counter = _OTPUtils2['default'].intToHex(counter);
      counter = _OTPUtils2['default'].pad(counter, 16);

      // HMAC creation
      var cryptoHmac = _crypto2['default'].createHmac('sha1', new Buffer(secret, 'hex'));

      // Update HMAC with the counter
      var hmac = cryptoHmac.update(new Buffer(counter, 'hex')).digest('hex');

      // offset := last nibble of hash
      var offset = _OTPUtils2['default'].hexToInt(hmac.substr(hmac.length - 1));

      // truncatedHash := hash[offset..offset+3]
      // (4 bytes starting at the offset)
      var truncatedHash = hmac.substr(offset * 2, 8);

      // Set the first bit of truncatedHash to zero
      // (i.e. remove the most significant bit)
      var sigbit0 = _OTPUtils2['default'].hexToInt(truncatedHash) & _OTPUtils2['default'].hexToInt('7fffffff');

      // code := truncatedHash mod 1000000
      var code = sigbit0 % Math.pow(10, this.digits);

      // Pad code with 0 until length of code is 6
      code = _OTPUtils2['default'].pad(code, this.digits);

      return code;
    }

    /**
     * Checks the provided OTP token against system generated token
     *
     * @method check
     *
     * @param {string} token - the OTP token to check
     * @param {string} secret - your secret that is used to generate the token
     * @param {number} counter - the OTP counter (usually it's an incremental count)
     * @return {boolean}
     */
  }, {
    key: 'check',
    value: function check(token, secret) {
      var counter = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

      var systemToken = this.generate(secret, counter);
      return _OTPUtils2['default'].isSameToken(token, systemToken);
    }
  }]);

  return HOTP;
})();

exports['default'] = HOTP;
module.exports = exports['default'];